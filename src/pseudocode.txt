// triangle : th, tx, ty, th hypotenus


// Data
const defaultWords = [
  { id: "1234", text: "test", x: 10, y: 100 },
  { id: "2345", text: "hello", x: 50, y: 10 },
  { id: "3456", text: "haha", x: 130, y: 40 },
];

// sort the dataset 
function sortData(data){
    return data.x.sort()
}

function centre(w){
    x = x + w/2
    y = y + h/2

    return x, y
}

function distance(p1, p2){
    return sqrt((p2.x - p1.x)^2 + (p2.y-p1.y)^2)
}

// force résultante entre un rectangle (en son centre) et tout les centres des autres rectangles
// input: current point, list[center of all already done rect]
// output: a line (by equation or two points)

function netForce(point, passRect){

    distance = []
    Force = []

    xForce = []
    yForce = []

    for(rect in passRect){

        // calculate distance between each rectangles
        d = distance(point, rect)
        distance.push(d)


        // calculate the force of gravity between the object
        F = G * 1 / d^2

        Force.push(F)

        // calculate the x anf y components of the forces

        angle = arctan((rect.y - point.y)/(rect.x - point.x))

        Fx = F * cos(angle)
        Fy = F * sin(angle)

        xForce.push(Fx)
        yForce.push(Fy)

        sumXForce = xForce.sum()
        sumYForce = yForce.sum()

        coordinateF = sumXForce * i + sumYForce * j



        return [sumXForce, sumYForce]

    }
}

// fonction qui retourne un triangle rectangle avec comme hypoténus la droite de la force résultante 

function getTriangleFromNetForce(netForce){
    return th, tx, ty

}

// fonction qui donne la nouvelle valeur de x, suivant la droite de la force résultante, pour un déplacement d'une valeur step

function stepX(x, th, tx, step){
    val = (step/th) * tx 
    return x + val
}

// fonction qui donne la nouvelle valeur de y, suivant la droite de la force résultante, pour un déplacement d'une valeur step

function stepY(x, th, ty, step){
    val = (step/th) * ty
    return y + val
}

function futurPosition(rect, passRect, step){

    netForce = netForce(rect, passRect)
    th, tx, ty = getTriangleFromNetForce(netForce)

    xFutur = stepX(rect.x, th, tx, step)
    yFutur = stepY(rect.y, th, ty, step)

    tmp.x = xFutur
    tmp.y = yFutur


    if (allCollision(tmp, passRect)){

        collisionDirection = [0, 0]

        case 1:
            tmp.x = rect.x
            if (allCollision(tmp, passRect)){
                // there is a collision on y
                collisionDirection[1] = 1
            }

        case 2:
            tmp.y = rect.y
            if (allCollision(tmp, passRect)){
                // there is a collision on x
                collisionDirection[0] = 1
            }

        if (collisionDirection == [1, 1]){
            // collison on both direction
            // return position initial de rect
            return rect 

        } else {
            if (collisionDirection == [1, 0]){
                // collision on x 

                rect.y += xFutur
                futurPosition(rect, passRect, step)
            }

            if (collisionDirection == [0, 1]){
                // collision on y

                rect.x += yFutur
                futurPosition(rect, passRect, step)
            }
        }      
    } else {
        futurPosition(tmp, passRect, step)
    }

}



// fonction qui retourne true s'il y a une collision  

function collision(rect1, rect2){
    const x1 = word1.x;
    const y1 = word1.y;
    const w1 = document.getElementById(word1.id).getBoundingClientRect().width;
    const h1 = document.getElementById(word1.id).getBoundingClientRect().height;

    const x2 = word2.x;
    const y2 = word2.y;
    const w2 = document.getElementById(word2.id).getBoundingClientRect().width;
    const h2 = document.getElementById(word2.id).getBoundingClientRect().height;

    if (x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && h1 + y1 > y2) {
      console.log("collision");
      return collision;
    } else {
      return not collision;
    }
}

// fonction qui retourne true s'il y a une collision entre le rectangle et les rectangles déjà posé

function allCollision(rect, passRect)
 wordArray.for((w: { id: string; text: string; x: number; y: number }) => {
    if (word.id != w.id) {
      if (collision(word, w)) {
        console.log("collision");
        return true;
      } else {
        console.log("No collision");

        return false;
      }
    }
    return false;
  });



  function main(){

    passRect = []

    defaultWords = sortData(defaultWords)

    // iterate over each word, already put word in passWord array
    defaultWords.forEach(w => 

        if (passRect == empty){
            w.x = center
            w.y = center

            passRect.push(w)
        } else {

            w = futurPosition(w, passWord, step)
            passRect.push(w)

        }

        return w;

    )

  }

  function finish(passRect){
    if (passRect == passWord){
        // the word cloud is finish
    }
  }